module Bitsquid
	# Class for generating HTML code.
	#
	# The code is generated by calling add() multiple times to add lines of HTML content enclosed in
	# particular tags. When all the data has been added, generate() is called to generate the final
	# document. The generator takes caring of adding open- and close- tags so that every line gets
	# the required tags. It also formats the HTML in a nice way.
	#
	# Example:
	#
	#    require_relative 'generator'
	#    
	#    gen = Bitsquid::Generator.new()
	#    gen.add(%w(h1), "Header")
	#    gen.add(%w(ul li p),  "One item")
	#    gen.add(%w(ul), nil)
	#    gen.add(%w(ul li p), "One item")
	#    gen.add(%w(ul li p), "with two lines")
	#    puts(gen.generate())
	#
	# Result:
	#
	#    <h1>Header</h1>
	#    
	#    <ul>
	#    	<li><p>One item</p></li>
	#    	<li>
	#    		<p>
	#    			One item
	#    			with two lines
	#    		</p>
	#    	</li>
	#    </ul>
	class Generator
		# Accessor for accessing the lines of the document. Each line is a struct with
		# two fields, :context for the list of tags and :line for the text.
		attr_reader :lines

		def initialize
			@line = Struct.new(:context, :line)
			@lines = []
		end

		# Adds a new line to the HTML document. context is the list of tags that the
		# line should use. E.g., if the context is %w(ul li p) the line will be enclosed
		# in <ul><li><p>
		#
		# When generating the output, contexts are merged with neighboring lines, the tags
		# that don't match the tags of the previous line are automatically opened and closed.
		#
		# You can use nil for the line text to create empty tags.
		#
		# Tags in the context can include parameters, as in: ['div class="menu"', 'h1']
		def add(context, line)
			@lines << @line.new(context, line)
		end

		# Generates the HTML document and returns it as a string.
		def generate()
			@out = []
			@context = []

			trim_nil_lines

			@lines.each_with_index do |line, i|
				write_with_context(line.line, line.context, next_context(i))
			end
			write_with_context(nil, [], [])
			return @out.join
		end

	private
		def trim_nil_lines()
			i = 0
			while i+1 < @lines.size do
				a = @lines[i]
				b = @lines[i+1]
				if a.line == nil && (a.context == b.context || a.context != b.context[0,a.context.size])
					@lines[i,1] = []
				else
					i += 1
				end
			end
		end

		def pop_whitespace
			@out.pop while @out.last =~ /^\s*$/
		end

		def next_context(i)
			return @lines[i+1] ? @lines[i+1].context : []
		end
		
		def first_word(t)
			return t.split(' ').first
		end

		def write_with_context(line, context, next_context)
			while @context.size > 0 && (@context.size > context.size || @context[-1] != context[@context.size-1])
				close_context()
			end

			i = @context.size
			while context.size > i && i < next_context.size && context[i] == next_context[i]
				open_context(context[i])
				i = i+1
			end

			if line
				puts "" if @context.size == 0 && @out.size > 0
				tags = context[i..-1]
				start = tags.collect {|t| "<#{t}>"}.join('')
				stop = tags.reverse.collect {|t| "</#{first_word(t)}>"}.join('')
				puts start + line + stop
			end
		end

		def open_context(tag)
			puts "" if @context.size == 0 && @out.size > 0
			puts "<#{tag}>"
			@context.push(tag)
			pop_whitespace() if first_word(tag) == 'pre'
		end

		def close_context()
			tag = @context.pop
			if first_word(tag) == 'pre'
				pop_whitespace()
				@out << "</pre>" << "\n"
			else
				puts "</#{first_word(tag)}>"
			end
		end

		def puts(text)
			@out << ("\t" * @context.size) unless @context.size > 0 && first_word(@context.last) == 'pre'
			@out << text << "\n"
		end
	end
end